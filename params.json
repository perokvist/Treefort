{"name":"Treefort","tagline":"Exploring CQRS / ES on the CLR + Azure","body":"#Treefort\r\n\r\nSmall infrastructure parts, for DDD/CQRS/Event sourcing. To explore and create labs.\r\n\r\n**Current release 0.3.0-beta** on dev branch.\r\n\r\n[MyGet Feed](https://www.myget.org/F/treefort/ \"MyGet feed\") for beta builds.\r\n\r\n## ApplicationServer\r\n\r\nWhen using Treefort in a non distributed scenario, like in app, the ApplicationServer is your starting point.\r\nAn ApplicationServer is an InMemoryCommandBus and CommandDispatcher (implements ICommandBus and ICommandDispatcher).\r\nTo create an ApplicationServer you need a dispatcher and a logger. The following code shows a simple InMemory scenario.\r\n\r\n        var logger = new ConsoleLogger();\r\n        var store = new InMemoryEventStore(() => new InMemoryEventStream());\r\n\r\n        var dispatcher = new Dispatcher<ICommand, Task>();\r\n        \r\n        dispatcher.Register<ChangeNameCommand>(command => \r\n\t\t\tApplicationService.UpdateAsync<CarAggregate, CarState>\r\n\t\t\t(state => new CarAggregate(state), store, command, aggregate => aggregate.ChangeName(command.NewName)));\r\n\r\n        var server = new ApplicationServer(dispatcher.Dispatch, logger);\r\n\r\n#### Another sample\r\n\r\n       var commandDispatcher = new Dispatcher<ICommand, Task>();\r\n\r\n            var awailableGames = new AwailableGames();\r\n            var endedGames = new EndendGames();\r\n\r\n            var eventPublisher = new EventPublisher(Console.WriteLine, new ProjectionEventListener(awailableGames, endedGames));\r\n            var eventStore = new PublishingEventStore(new InMemoryEventStore(() => new InMemoryEventStream()), eventPublisher);\r\n\r\n            commandDispatcher.Register<IGameCommand>(\r\n                command => ApplicationService.UpdateAsync<RPS.Game.Domain.Game, GameState>(\r\n                    state => new RPS.Game.Domain.Game(state), eventStore, command, game => game.Handle(command)));\r\n\r\n            var bus = new ApplicationServer(commandDispatcher.Dispatch, new ConsoleLogger());\r\n\r\n\r\n##Receptors\r\n\r\nTreefort support receptors through publishing events via an EventPublisher. The EventPublisher could publish to several EventListeners, one of the specific for recptors.\r\n\r\n            var logger = new ConsoleLogger();\r\n            var dispatcher = new Dispatcher<ICommand, Task>();\r\n            var server = new ApplicationServer(dispatcher.Dispatch, logger);\r\n            var receptorListener = new ReceptorListener(Enumerable.Empty<IReceptor>(), server);\r\n\r\n            var store = new PublishingEventStore(new InMemoryEventStore(() => new InMemoryEventStream()), new EventPublisher(new[] { receptorListener }, logger));\r\n            \r\n            dispatcher.Register<ChangeNameCommand>(command => ApplicationService.UpdateAsync<CarAggregate, CarState>(state => new CarAggregate(state), store, command,\r\n                aggregate => aggregate.ChangeName(command.NewName)));\r\n\r\n\r\nHere we create an PublishingEventStore decorator, this enables publishing events to IEventListener, one such listener is the ReceptorListener. Is the code above no receptors is given to the listener.\r\nCreation of a Receptor is simple.\r\n\t\r\n\tpublic interface IReceptor \r\n\t    {\r\n\t        Task<ICommand> HandleAsync(IEvent @event);\r\n\t    }\r\n\r\n##Process Managers\r\n\r\nIt is possible to implement process manager through the IReceptor interface. Same persistence helpers apply here, then the process manages state is eventsourced as well.\r\n\r\n##Application Services\r\n\r\nThe are many was of using application services.\r\n\r\n      dispatcher.Register<ChangeNameCommand>(command => \r\n\t\t\tApplicationService.UpdateAsync<CarAggregate, CarState>\r\n\t\t\t(state => new CarAggregate(state), store, command, aggregate => aggregate.ChangeName(command.NewName)));\r\n\r\nIf you like a class implementation for each application service there are to helper classes. *StatelessApplicationService* and *StatefulApplicationService*. Both have some helper method for publishing/updating events/state.\r\n\r\n###Stateless\r\n\r\n    public class TestApplicationService : StatelessApplicationService, IApplicationService\r\n    {\r\n        public TestApplicationService(IEventPublisher eventPublisher) : base(eventPublisher)\r\n        {}\r\n\r\n        public Task HandleAsync(Commanding.ICommand command)\r\n        {\r\n            return When((dynamic)command);\r\n        }\r\n\r\n        public void When(TestCommand command)\r\n        {\r\n            Do(action =>\r\n            {\r\n                action(command,new TestEvent());\r\n                action(command,new TestEventTwo());\r\n                return Task.FromResult(new object());\r\n            });  \r\n        }\r\n\t}\r\n\r\n\r\n###Stateful\r\n\r\n    public class ProcessApplicationService : StatefulApplicationService<TestAggregate, TestState>, \r\n        IApplicationService\r\n    {\r\n        public ProcessApplicationService(IEventStore eventStore)\r\n            : base(eventStore, state => new TestAggregate(state))\r\n        {\r\n        }\r\n        \r\n        public Task HandleAsync(ICommand command)\r\n        {\r\n            return When((dynamic) command);\r\n        }\r\n\t}\r\n\r\n###Rx\r\n\r\nInstead of using the PublishingEventStore, you could use the ObservableEventStore. This way you could subscribe to events from the eventstore. Another way is to create an eventlistener that publishes events to Subject.\r\nIf you are using EventStore (geteventstore) use their subscriptions model (you could sprikle that with Rx as well).\r\nYou could use the PublishEventStore together with ObservableEventStore, just create ObservableEventStore with PublishEventStore.\r\n\r\n###Azure\r\n\r\nThe Azure project contains processors to aid messaging of commands and events. This trough either Queues or Topics. The bases is same as in the CQRS journey project, updated for the message pump functionallity.\r\n\r\nIf you are using eventstore, use the subscription model when you can.\r\n\r\n####Azure Sample Client\r\n\r\n \tclass Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"Starting...\");\r\n            var connectionString = ConfigurationManager.AppSettings[\"Microsoft.ServiceBus.ConnectionString\"];\r\n            var manager = NamespaceManager.CreateFromConnectionString(connectionString);\r\n            const string path = \"commands\";\r\n            if(!manager.QueueExists(path))\r\n                manager.CreateQueue(path);\r\n            var bus = new CommandBus(new QueueSender(connectionString, path), new JsonTextSerializer());\r\n            for (var i = 0; i < 3; i++)\r\n            {\r\n                Console.WriteLine(\"Sending command {0}\", i + 1);\r\n                bus.SendAsync(new SampleCommand()).Wait();\r\n            }\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n\r\n\r\n####Azure Sample Processor\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var connectionString = ConfigurationManager.AppSettings[\"Microsoft.ServiceBus.ConnectionString\"];\r\n            var dispatcher = new Dispatcher<ICommand, Task>();\r\n            dispatcher.Register<SampleCommand>(command => Task.Run(() => Console.WriteLine(\"Received {0}\", command.AggregateId)));\r\n            const string path = \"commands\";\r\n\r\n            var processor = new CommandProcessor(new QueueReceiver(connectionString, path), new CommandDispatcherAction(dispatcher.Dispatch), new JsonTextSerializer());\r\n            processor.Start();\r\n            Console.ReadLine();\r\n            processor.Stop();\r\n        }\r\n    }\r\n\r\n####Azure Sample Session Processor\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var connectionString = ConfigurationManager.AppSettings[\"Microsoft.ServiceBus.ConnectionString\"];\r\n            var logger = new ConsoleLogger();\r\n            var store = new InMemoryEventStore(() => new InMemoryEventStream());\r\n            var dispatcher = new Dispatcher<ICommand, Task>();\r\n            dispatcher.Register<SampleSessionCommand>(command => Task.Run(() => Console.WriteLine(\"Received Session Command {0} Session: {1}\", command.AggregateId, command.SessionId)));\r\n\r\n            const string path = \"commands\";\r\n\r\n            var processor = new CommandProcessor(new SessionQueueReceiver(connectionString, path, Console.WriteLine), new CommandDispatcherAction(dispatcher.Dispatch), new JsonTextSerializer());\r\n             \r\n            processor.Start();\r\n            Console.ReadLine();\r\n            processor.Stop();\r\n        }\r\n    }\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}