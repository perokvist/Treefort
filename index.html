<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Treefort : Exploring CQRS / ES on the CLR + Azure">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Treefort</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/perokvist/Treefort">View on GitHub</a>

          <h1 id="project_title">Treefort</h1>
          <h2 id="project_tagline">Exploring CQRS / ES on the CLR + Azure</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/perokvist/Treefort/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/perokvist/Treefort/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="treefort" class="anchor" href="#treefort"><span class="octicon octicon-link"></span></a>Treefort</h1>

<p>Small infrastructure parts, for DDD/CQRS/Event sourcing. To explore and create labs.</p>

<p><strong>Current release 0.3.0-beta</strong> on dev branch.</p>

<p><a href="https://www.myget.org/F/treefort/" title="MyGet feed">MyGet Feed</a> for beta builds.</p>

<h2>
<a name="applicationserver" class="anchor" href="#applicationserver"><span class="octicon octicon-link"></span></a>ApplicationServer</h2>

<p>When using Treefort in a non distributed scenario, like in app, the ApplicationServer is your starting point.
An ApplicationServer is an InMemoryCommandBus and CommandDispatcher (implements ICommandBus and ICommandDispatcher).
To create an ApplicationServer you need a dispatcher and a logger. The following code shows a simple InMemory scenario.</p>

<pre><code>    var logger = new ConsoleLogger();
    var store = new InMemoryEventStore(() =&gt; new InMemoryEventStream());

    var dispatcher = new Dispatcher&lt;ICommand, Task&gt;();

    dispatcher.Register&lt;ChangeNameCommand&gt;(command =&gt; 
        ApplicationService.UpdateAsync&lt;CarAggregate, CarState&gt;
        (state =&gt; new CarAggregate(state), store, command, aggregate =&gt; aggregate.ChangeName(command.NewName)));

    var server = new ApplicationServer(dispatcher.Dispatch, logger);
</code></pre>

<h4>
<a name="another-sample" class="anchor" href="#another-sample"><span class="octicon octicon-link"></span></a>Another sample</h4>

<pre><code>   var commandDispatcher = new Dispatcher&lt;ICommand, Task&gt;();

        var awailableGames = new AwailableGames();
        var endedGames = new EndendGames();

        var eventPublisher = new EventPublisher(Console.WriteLine, new ProjectionEventListener(awailableGames, endedGames));
        var eventStore = new PublishingEventStore(new InMemoryEventStore(() =&gt; new InMemoryEventStream()), eventPublisher);

        commandDispatcher.Register&lt;IGameCommand&gt;(
            command =&gt; ApplicationService.UpdateAsync&lt;RPS.Game.Domain.Game, GameState&gt;(
                state =&gt; new RPS.Game.Domain.Game(state), eventStore, command, game =&gt; game.Handle(command)));

        var bus = new ApplicationServer(commandDispatcher.Dispatch, new ConsoleLogger());
</code></pre>

<h2>
<a name="receptors" class="anchor" href="#receptors"><span class="octicon octicon-link"></span></a>Receptors</h2>

<p>Treefort support receptors through publishing events via an EventPublisher. The EventPublisher could publish to several EventListeners, one of the specific for recptors.</p>

<pre><code>        var logger = new ConsoleLogger();
        var dispatcher = new Dispatcher&lt;ICommand, Task&gt;();
        var server = new ApplicationServer(dispatcher.Dispatch, logger);
        var receptorListener = new ReceptorListener(Enumerable.Empty&lt;IReceptor&gt;(), server);

        var store = new PublishingEventStore(new InMemoryEventStore(() =&gt; new InMemoryEventStream()), new EventPublisher(new[] { receptorListener }, logger));

        dispatcher.Register&lt;ChangeNameCommand&gt;(command =&gt; ApplicationService.UpdateAsync&lt;CarAggregate, CarState&gt;(state =&gt; new CarAggregate(state), store, command,
            aggregate =&gt; aggregate.ChangeName(command.NewName)));
</code></pre>

<p>Here we create an PublishingEventStore decorator, this enables publishing events to IEventListener, one such listener is the ReceptorListener. Is the code above no receptors is given to the listener.
Creation of a Receptor is simple.</p>

<pre><code>public interface IReceptor 
    {
        Task&lt;ICommand&gt; HandleAsync(IEvent @event);
    }
</code></pre>

<h2>
<a name="process-managers" class="anchor" href="#process-managers"><span class="octicon octicon-link"></span></a>Process Managers</h2>

<p>It is possible to implement process manager through the IReceptor interface. Same persistence helpers apply here, then the process manages state is eventsourced as well.</p>

<h2>
<a name="application-services" class="anchor" href="#application-services"><span class="octicon octicon-link"></span></a>Application Services</h2>

<p>The are many was of using application services.</p>

<pre><code>  dispatcher.Register&lt;ChangeNameCommand&gt;(command =&gt; 
        ApplicationService.UpdateAsync&lt;CarAggregate, CarState&gt;
        (state =&gt; new CarAggregate(state), store, command, aggregate =&gt; aggregate.ChangeName(command.NewName)));
</code></pre>

<p>If you like a class implementation for each application service there are to helper classes. <em>StatelessApplicationService</em> and <em>StatefulApplicationService</em>. Both have some helper method for publishing/updating events/state.</p>

<h3>
<a name="stateless" class="anchor" href="#stateless"><span class="octicon octicon-link"></span></a>Stateless</h3>

<pre><code>public class TestApplicationService : StatelessApplicationService, IApplicationService
{
    public TestApplicationService(IEventPublisher eventPublisher) : base(eventPublisher)
    {}

    public Task HandleAsync(Commanding.ICommand command)
    {
        return When((dynamic)command);
    }

    public void When(TestCommand command)
    {
        Do(action =&gt;
        {
            action(command,new TestEvent());
            action(command,new TestEventTwo());
            return Task.FromResult(new object());
        });  
    }
}
</code></pre>

<h3>
<a name="stateful" class="anchor" href="#stateful"><span class="octicon octicon-link"></span></a>Stateful</h3>

<pre><code>public class ProcessApplicationService : StatefulApplicationService&lt;TestAggregate, TestState&gt;, 
    IApplicationService
{
    public ProcessApplicationService(IEventStore eventStore)
        : base(eventStore, state =&gt; new TestAggregate(state))
    {
    }

    public Task HandleAsync(ICommand command)
    {
        return When((dynamic) command);
    }
}
</code></pre>

<h3>
<a name="rx" class="anchor" href="#rx"><span class="octicon octicon-link"></span></a>Rx</h3>

<p>Instead of using the PublishingEventStore, you could use the ObservableEventStore. This way you could subscribe to events from the eventstore. Another way is to create an eventlistener that publishes events to Subject.
If you are using EventStore (geteventstore) use their subscriptions model (you could sprikle that with Rx as well).
You could use the PublishEventStore together with ObservableEventStore, just create ObservableEventStore with PublishEventStore.</p>

<h3>
<a name="azure" class="anchor" href="#azure"><span class="octicon octicon-link"></span></a>Azure</h3>

<p>The Azure project contains processors to aid messaging of commands and events. This trough either Queues or Topics. The bases is same as in the CQRS journey project, updated for the message pump functionallity.</p>

<p>If you are using eventstore, use the subscription model when you can.</p>

<h4>
<a name="azure-sample-client" class="anchor" href="#azure-sample-client"><span class="octicon octicon-link"></span></a>Azure Sample Client</h4>

<pre><code>class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Starting...");
        var connectionString = ConfigurationManager.AppSettings["Microsoft.ServiceBus.ConnectionString"];
        var manager = NamespaceManager.CreateFromConnectionString(connectionString);
        const string path = "commands";
        if(!manager.QueueExists(path))
            manager.CreateQueue(path);
        var bus = new CommandBus(new QueueSender(connectionString, path), new JsonTextSerializer());
        for (var i = 0; i &lt; 3; i++)
        {
            Console.WriteLine("Sending command {0}", i + 1);
            bus.SendAsync(new SampleCommand()).Wait();
        }
        Console.ReadLine();
    }
}
</code></pre>

<h4>
<a name="azure-sample-processor" class="anchor" href="#azure-sample-processor"><span class="octicon octicon-link"></span></a>Azure Sample Processor</h4>

<pre><code>class Program
{
    static void Main(string[] args)
    {
        var connectionString = ConfigurationManager.AppSettings["Microsoft.ServiceBus.ConnectionString"];
        var dispatcher = new Dispatcher&lt;ICommand, Task&gt;();
        dispatcher.Register&lt;SampleCommand&gt;(command =&gt; Task.Run(() =&gt; Console.WriteLine("Received {0}", command.AggregateId)));
        const string path = "commands";

        var processor = new CommandProcessor(new QueueReceiver(connectionString, path), new CommandDispatcherAction(dispatcher.Dispatch), new JsonTextSerializer());
        processor.Start();
        Console.ReadLine();
        processor.Stop();
    }
}
</code></pre>

<h4>
<a name="azure-sample-session-processor" class="anchor" href="#azure-sample-session-processor"><span class="octicon octicon-link"></span></a>Azure Sample Session Processor</h4>

<pre><code>class Program
{
    static void Main(string[] args)
    {
        var connectionString = ConfigurationManager.AppSettings["Microsoft.ServiceBus.ConnectionString"];
        var logger = new ConsoleLogger();
        var store = new InMemoryEventStore(() =&gt; new InMemoryEventStream());
        var dispatcher = new Dispatcher&lt;ICommand, Task&gt;();
        dispatcher.Register&lt;SampleSessionCommand&gt;(command =&gt; Task.Run(() =&gt; Console.WriteLine("Received Session Command {0} Session: {1}", command.AggregateId, command.SessionId)));

        const string path = "commands";

        var processor = new CommandProcessor(new SessionQueueReceiver(connectionString, path, Console.WriteLine), new CommandDispatcherAction(dispatcher.Dispatch), new JsonTextSerializer());

        processor.Start();
        Console.ReadLine();
        processor.Stop();
    }
}
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Treefort maintained by <a href="https://github.com/perokvist">perokvist</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
